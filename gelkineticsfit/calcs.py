# Functions perform calculations and fits for fraction folded data

from scipy.optimize import curve_fit
import numpy as np
import pandas as pd
import statistics

def av_by_cond_in_data_dict(data_dict: dict) -> dict:
    """Takes a data_dict generated by parse.parse_raw_kinetics_xlsx() and averages the fraction
    folded for each reaction of a conditions.
    Returns:
    averaged_data_dict = {
        "<condition>" : DataFrame
    }
    Where dataframe columns are:
    Time (s) : Time points
    Average Fraction Folded
    Range: Range of Fraction folded values
    Std Dev: Standard Deviation of Fraction folded values
    Std Error: Standard Error of Fraction folded values
    """

    avdata_dict ={}
    for condition, reactions_dict in data_dict.items():
        print(f"Processing condition {condition}")
        num_rxns = len(reactions_dict) # to check we got everything later
        avdata_dict[condition] = None # create empty dataframe to add data to
        
        for reaction_name, df in reactions_dict.items(): # need ind for column naming
            if avdata_dict[condition] is None: # first create df with time col
                avdata_dict[condition] = df.iloc[:, 0].copy(deep=True).to_frame() # time is first col

            avdata_dict[condition][reaction_name] = df.iloc[:, 1].copy(deep=True)
        
        avdata_dict[condition] = avdata_dict[condition].set_index("Time (s)") # set time as index

        num_columns = len(avdata_dict[condition].columns)
        
        if num_columns != num_rxns:
            print(f"Warning!: For condition: {condition} number of extracted fraction folded columns ({num_columns}) doesn't match number of reactions ({num_rxns})")
            print(f"Something may have gone wrong")
        
        avdata_dict[condition] = avdata_dict[condition].aggregate(
            ["mean", "std", "min", "max", "count"], axis="columns"
        )
        avdata_dict[condition]["range"] = avdata_dict[condition]["max"] - avdata_dict[condition]["min"]
        avdata_dict[condition] = avdata_dict[condition].reset_index() # bring the time column back
    
    return avdata_dict
    
# Fits

def one_phase_decay(x, k, yo, plateau):
    #yo = 0  #value of y when x=0
    #plateau = 1  #value of y at infinite x
    return (yo - plateau)*(np.exp((-k*x).astype(float))) + plateau

def fit_one_folding_reaction(x: pd.Series, y: pd.Series, fit_func=one_phase_decay) -> dict:
    """Performs curve fitting using scipy.optimize.curve_fit kinetics data.
    x should be the timepoints and y should be the fraction folded. Returns a 
    dictionary containing the fit parameters (popt) and error (pcov)"""
    
    # found this doesn't work without specifying starting params and increasing maxfev
    popt, pcov = curve_fit(
        fit_func, 
        x, 
        y,
        # force y0 to be as close to 0 as possible and plateau to be between 0 and 1
        bounds=( (-np.inf, -0.000001, 0), (np.inf, 0.000001, 1) ),
        p0=[0.01, 0, 0.6], 
        maxfev = 10000
    )

    individual_fit_dict = {
        "popt" : popt,
        "pcov" : pcov
    }
    
    return individual_fit_dict

def get_fit_params_dict2(data_dict: dict) -> dict:
    """
    Performs curve fitting using scipy.optimize.curve_fit on kinetics dataframes
    contained in a data_dict as generated by parse_raw_kinetics_xlsx(). Returns
    a fitting_dict where top two levels are "conditions" and "reactions"
    as specified in the input data_dict and where values under "reactions" are a dict 
    containing the output popt and pcov from the fitting.
    Returns:
    fitting_dict = {
        "<condition>" : {
            "<reaction_name>" : {
                "popt" : popt, --> [k, y0, plateau]
                "pcov" : pcov
            },
            etc.
        },
        etc.
    }
    """

    fitting_dict = {}
    for condition, reactions_dict in data_dict.items():
        print("Condition:", condition)
        fitting_dict[condition] = {}
        for reaction_name, kinetics_df in reactions_dict.items():
            x = kinetics_df.iloc[:, 0] # first column should be time
            y = kinetics_df.iloc[:, 1] # second column should be average fraction folded

            fitting_dict[condition][reaction_name] = fit_one_folding_reaction(x, y)
            popt = fitting_dict[condition][reaction_name]["popt"]
            pcov = fitting_dict[condition][reaction_name]["pcov"]

            print(f"{reaction_name}: ")
            print(f"k: {popt[0]:.2E} y0: {popt[1]:.2E} plateau: {popt[2]}")
            print(f"pcov: {pcov}")
    
    return fitting_dict

def get_fit_params_dict_from_avdata_dict(avdata_dict: dict) -> dict:
    """Performs curve fitting using scipy.optimize.curve_fit() on kinetics data averaged by
    reaction as contained in a avdata_dict generated by av_by_cond_in_data_dict.
    Returns:
    avfitting_dict = {
        "<condition>" : {
            "popt" : popt, --> [k, y0, plateau]
            "pcov" : pcov
        }
    }
    """
    
    avfitting_dict = {}
    for condition, averaged_df in avdata_dict.items():
        print("Condition:", condition)
        x = averaged_df.iloc[:, 0] # first column should be time
        y = averaged_df.iloc[:, 1] # second column should be average fraction folded

        avfitting_dict[condition] = fit_one_folding_reaction(x, y)
        popt = avfitting_dict[condition]["popt"]
        pcov = avfitting_dict[condition]["pcov"]

        print(f"{condition}: ")
        print(f"k: {popt[0]:.2E} y0: {popt[1]:.2E} plateau: {popt[2]}")
        print(f"pcov: {pcov}\n")
    
    return avfitting_dict


def linear(x: float, m: float, c: float) -> float:
    # c = 0 # force fit through 0
    return m*x + c

def calculate_init_rate2(fitting_dict: dict, sampling: int=1000) -> dict:
    """
    Calculates initial rates of folding based on single exponential curves fitted to the raw data by get_fit_params_dict.
    Takes fitting parameters from fitting_dict. Uses single exponential equation and fitting parameters to generate points
    for the first 540s of the folding reaction with number of points specified by sampling arg. Then performs a linear fit
    to that data where the initial rate is the slope of the best fit line. Assumes a two level dict (first level is 
    condition, e.g. BAM WT + DAR-B; second level is individual folding reaction for that condition)
    Returns:
    init_rate_dict = {
        "<condition>" : {
            "<reaction_name>" : {
                "popt" : popt, --> [m(init_rate), c]
                "pcov" : pcov,
                "x" : x,
                "y" : y
            },
            etc.
        },
        etc.
    }
    """

    init_rate_dict = {}
    for condition, reactions_dict in fitting_dict.items():
        print("Condition:", condition)
        init_rate_dict[condition] = {}
        for reaction_name, fit_dict in reactions_dict.items():
            x = np.linspace(0, 540, sampling) # generate points between 0 and 540s
            single_exponential_popt = fit_dict["popt"]
            y = one_phase_decay(np.array(x), *single_exponential_popt) # generate points using fit over timespan

            popt, pcov = curve_fit(linear, x, y)

            init_rate_dict[condition][reaction_name] = {
                "popt" : popt,
                "pcov" : pcov,
                "x" : x,
                "y" : y
            }
        
            print(f"{reaction_name}:\npopt:\nm: {popt[0]:.2E} c: {popt[1]:.2E}\npcov:\nm: {pcov[0]} c: {pcov[1]}")

    return init_rate_dict

def get_average_init_rate(init_rate_dict, condition):
    """Returns the average init rate across all reactions for a condition within
    an init_rate_dict"""

    to_sum = []
    i = 0
    for reaction in init_rate_dict[condition]:
        init_rate = init_rate_dict[condition][reaction]["popt"][0]
        to_sum.append(init_rate)
        i += 1

    return sum(to_sum)/i 

def init_rates_as_percent_control(init_rate_dict, control):
    """Takes initial rates from init_rate_dict calculated with calculate_init_rate
    and generates initial rates as a percentage of that specified in the control
    returns these in an init_rates_percent_dict. control should be the key
    for the first level of the init_rate_dict to specify which condition to
    use as the control. e.g. control = "WT BAM" would use the average initial
    rate of WT BAM as the reference to calculate percentage initial rates
    returns:
    norm_init_rate_dict = {
        "<condition>" : {
            "<reaction_name>" : <normalised_initial_rate>
            etc.
        },
        etc.
    }
    
    """

    cont_av_init_rate = get_average_init_rate(init_rate_dict, control)

    norm_init_rate_dict = {}
    for condition, reactions_dict in init_rate_dict.items():
        print("Condition:", condition)
        norm_init_rate_dict[condition] = {}
        for reaction_name, rates_dict in reactions_dict.items():
            init_rate = rates_dict["popt"][0]
            norm_init_rate_dict[condition][reaction_name] = (init_rate/cont_av_init_rate)*100

    return norm_init_rate_dict